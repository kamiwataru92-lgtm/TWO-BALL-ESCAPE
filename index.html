<!DOCTYPE html>
<html lang="ja">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="UTF-8">
<title>TWO BALL ESCAPE</title>

<style>
body {
  margin: 0;
  background: #300;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
}

canvas {
  display: block;
  background: #111;
}

</style>
</head>

<body>
<canvas id="game"></canvas>

<script>

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const dpad = {
  x: 100,
  y: 0,
  size: 35
};

function resizeCanvas() {
  canvas.width = Math.min(window.innerWidth, 900);
  canvas.height = Math.min(window.innerHeight, 700);

  dpad.x = canvas.width / 2;
  dpad.y = canvas.height - 100;
}

resizeCanvas();
window.addEventListener("resize", resizeCanvas);


// ===== プレイヤー =====
const player = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  r: 10,
  speed: 4
};

// ===== タッチ方向 =====
const touchKeys = {
  up: false,
  down: false,
  left: false,
  right: false
};

// ===== 十字キー式タッチ操作 =====
canvas.addEventListener("touchstart", e => {
  const rect = canvas.getBoundingClientRect();

  for (let t of e.touches) {
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;

    if (Math.hypot(x - dpad.x, y - (dpad.y - 60)) < dpad.size) {
      touchKeys.up = true;
    }
    if (Math.hypot(x - dpad.x, y - (dpad.y + 60)) < dpad.size) {
      touchKeys.down = true;
    }
    if (Math.hypot(x - (dpad.x - 60), y - dpad.y) < dpad.size) {
      touchKeys.left = true;
    }
    if (Math.hypot(x - (dpad.x + 60), y - dpad.y) < dpad.size) {
      touchKeys.right = true;
    }
  }
});

canvas.addEventListener("touchend", () => {
  touchKeys.up = false;
  touchKeys.down = false;
  touchKeys.left = false;
  touchKeys.right = false;
});

// ===== 敵 =====
const enemies = [
  { x: 100, y: 100, r: 12, baseSpeed: 3.5, speed: 3.5, boostTimer: 0},
  { x: 700, y: 500, r: 12, baseSpeed: 4.5, speed: 4.5, boostTimer: 0}
];

// ===== キーボード =====
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

// ===== 時間 =====
let startTime = Date.now();
let gameOver = false;

// ===== 更新処理 =====
function update() {
  if (gameOver) return;

  // キーボード移動
  if (keys["w"] || keys["ArrowUp"]) player.y -= player.speed;
  if (keys["s"] || keys["ArrowDown"]) player.y += player.speed;
  if (keys["a"] || keys["ArrowLeft"]) player.x -= player.speed;
  if (keys["d"] || keys["ArrowRight"]) player.x += player.speed;

  // タッチ十字キー移動
if (touchKeys.up) player.y -= player.speed;
if (touchKeys.down) player.y += player.speed;
if (touchKeys.left) player.x -= player.speed;
if (touchKeys.right) player.x += player.speed;

  // 画面外防止
  player.x = Math.max(player.r, Math.min(canvas.width - player.r, player.x));
  player.y = Math.max(player.r, Math.min(canvas.height - player.r, player.y));

  // 敵処理
  enemies.forEach((enemy, index) => {
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const dist = Math.hypot(dx, dy);

    let angle = Math.atan2(dy, dx);
    angle += (Math.random() - 0.5) * 0.3;

    if (enemy.boostTimer <= 0 && Math.random() < 0.01) {
      enemy.boostTimer = 60;
    }

    if (enemy.boostTimer > 0) {
      enemy.speed = enemy.baseSpeed * 1.3;
      enemy.boostTimer--;
    } else {
      enemy.speed = enemy.baseSpeed;
    }

    if (index === 1) {
      angle += 0.5;
    }

    if (dist !== 0) {
      enemy.x += Math.cos(angle) * enemy.speed;
      enemy.y += Math.sin(angle) * enemy.speed;
    }

    if (dist < player.r + enemy.r) {
      gameOver = true;
    }
  });
}

// ===== 描画 =====
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "cyan";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();

  for (const enemy of enemies) {
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(enemy.x, enemy.y, enemy.r, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.fillStyle = "white";
  ctx.font = "20px sans-serif";
  const time = ((Date.now() - startTime) / 1000).toFixed(1);
  ctx.fillText(`Time: ${time}s`, 10, 25);

  if (gameOver) {
    ctx.fillStyle = "yellow";
    ctx.font = "40px sans-serif";
    ctx.fillText("GAME OVER", canvas.width/2 - 120, canvas.height/2);
  }

  // ===== D-pad描画 =====
  ctx.globalAlpha = 0.4;

  function drawButton(x, y, active) {
    ctx.fillStyle = active ? "white" : "gray";
    ctx.beginPath();
    ctx.arc(x, y, dpad.size, 0, Math.PI * 2);
    ctx.fill();
  }

drawButton(dpad.x, dpad.y - 60, touchKeys.up);
drawButton(dpad.x, dpad.y + 60, touchKeys.down);
drawButton(dpad.x - 60, dpad.y, touchKeys.left);
drawButton(dpad.x + 60, dpad.y, touchKeys.right);

  ctx.globalAlpha = 1;
}

// ===== ループ =====
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>

